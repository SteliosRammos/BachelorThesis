---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 1.0.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import pandas as pd
import numpy as np
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import roc_auc_score, average_precision_score, brier_score_loss
from sklearn.calibration import CalibratedClassifierCV
```

```{python}
base_path = '/Users/steliosrammos/Documents/Education/Maastricht/DKE-Year3/BachelorThesis/bachelor_thesis/'
train_data = pd.read_csv(base_path+"data/external/biased_train_diabetes.csv", sep=";")
test_data = pd.read_csv(base_path+"data/external/test_diabetes.csv", sep=";")
```

# Classifier S

```{python}
train_data.head()
```

```{python}
X_train, y_train = train_data.iloc[:, :-2], train_data.iloc[:, -2]
X_test, y_test = test_data.iloc[:, :-1], test_data.iloc[:, -1]
```

```{python}
from xgboost import XGBClassifier
```

```{python}
def compute_correction_weights(train_data):

    print('Start computing weights W')

    data_s = train_data.drop('class', axis=1)

    # Shuffle rows
    X = data_s.iloc[:, :-2]
    y = data_s.iloc[:, -1]

    # Startified k-fold
    sss = StratifiedKFold(n_splits=10, random_state=1)

    if type(y) == np.ndarray:
        prob_s_pos = np.bincount(y)[1] / len(y)
    else:
        prob_s_pos = y.value_counts(True)[1]

    roc_aucs = []
    pr_aucs = []
    brier_losses = []
    best_estimators = []
    splits = []
    predicted_prob_s = pd.Series(np.full(y.shape[0], np.nan))
    predicted_prob_s.index = y.index

    fold_num = 0

    for train_index, valid_index in sss.split(X, y):

        X_train, X_valid = X.iloc[train_index], X.iloc[valid_index]
        y_train, y_valid = y.iloc[train_index], y.iloc[valid_index]

        # Compute weights for test examples
        clf_s = XGBClassifier()
        clf_s.fit(X_train, y_train)
        
        predicted_prob_s.loc[X_valid.index] = clf_s.predict_proba(X_valid)[:, 1]

        for index in X_valid.index:
            if predicted_prob_s.loc[index] > 0:
                train_data.loc[index, 'weight'] = prob_s_pos / predicted_prob_s.loc[index]
            else:
                train_data.loc[index, 'weight'] = 0.001/prob_s_pos
        fold_num += 1

#         # Store fold results
#         roc_aucs.append(roc_auc)
#         pr_aucs.append(pr_auc)
#         brier_losses.append(brier_loss)
#         best_estimators.append(best_estimator)
#         splits.append([train_index, valid_index])
# 
#     print('Classifier S evaluation:')
#     print('Average ROC AUC: ', np.array(roc_aucs).mean())
#     print('Average PR AUC: ', np.array(pr_aucs).mean())
#     print('Average Brier Loss: {} \n'.format(np.array(brier_losses).mean()))
# 
#     return np.array(roc_aucs).mean(), np.array(brier_losses).mean()
    return True
```

```{python}
compute_correction_weights(train_data)
```

```{python}
train_data.head()
```

# Classifier Y

```{python}
def fit_correct(train_data, test_data):

    print('Start computing weights W')

    data_y = train_data.drop('got_go', axis=1)
    data_y = data_y[~data_y["class"].isna()]
    
    X_train, y_train, w = data_y.iloc[:, :-2], data_y.iloc[:, -1], data_y.iloc[:, -2]
    X_test, y_test = test_data.iloc[:, :-1], test_data.iloc[:, -1]
    
    # Startified k-fold
    sss = StratifiedKFold(n_splits=10, random_state=1)

    clf_y = XGBClassifier()
    skf_5 = StratifiedKFold(5, random_state=1)
    calibrated_clf_y = CalibratedClassifierCV(clf_y, cv=skf_5, method='isotonic')
    calibrated_clf_y.fit(X_train, y_train, sample_weight=w)
    
    predicted_probas = calibrated_clf_y.predict_proba(X_test)[:, 1]
    predicted_labels = calibrated_clf_y.predict(X_test)

    roc_score = roc_auc_score(y_test, predicted_probas)
    pr_score = average_precision_score(y_test, predicted_labels)
    brier_score = brier_score_loss(y_test, predicted_labels)

    print("ROC: {0:9.4f} \n PR: {1:9.4f} \n Brier: {2:9.4f} \n".format(roc_score, pr_score, brier_score))
```

```{python}
fit_correct(train_data, test_data)
```

```{python}

```
